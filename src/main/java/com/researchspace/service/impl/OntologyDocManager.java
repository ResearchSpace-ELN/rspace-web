package com.researchspace.service.impl;

import com.researchspace.model.User;
import com.researchspace.model.record.BaseRecord;
import com.researchspace.model.record.Folder;
import com.researchspace.model.record.RSForm;
import com.researchspace.model.record.StructuredDocument;
import com.researchspace.service.FolderManager;
import com.researchspace.service.FormManager;
import com.researchspace.service.RecordManager;
import com.researchspace.service.RecordSigningManager;
import com.researchspace.service.UserManager;
import com.researchspace.service.archive.ImportFailureException;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

@Slf4j
@Service("ontologyDocManager")
public class OntologyDocManager {
  public static final String USER_TAGS_ONTOLOGY_FILE = "YOUR_AUTOGENERATED_TAGS.ontology";
  public static final String RSPACE_EXTONTOLOGY_TAG_DELIMITER = "__RSP_EXTONT_TAG_DELIM__";
  public static final String RSPACE_EXTONTOLOGY_URL_DELIMITER = "__RSP_EXTONT_URL_DELIM__";
  public static final String RSPACE_EXTONTOLOGY_NAME_ONTOLOGYFILE = "__RSP_EXTONT_NAME__";
  public static final String RSPACE_EXTONTOLOGY_NAME_DELIM = "__RSP_EXTONT_NAME_DELIM__";
  public static final String RSPACE_EXTONTOLOGY_VERSION_DELIM = "__RSP_EXTONT_VERSION_DELIM__";
  public static final String RSPACE_EXTONTOLOGY_VERSION_ONTOLOGYFILES = "__RSP_EXTONT_VERSION__";

  static class OntologyDocWriter {
    public final int MAX_TERMS_PER_FIELD;

    OntologyDocWriter() {
      this.MAX_TERMS_PER_FIELD = 10000;
    }

    OntologyDocWriter(int maxItemsPerField) {
      this.MAX_TERMS_PER_FIELD = maxItemsPerField;
    }

    public void writeToOntologyDoc(
        StructuredDocument ontologyDocumentInWorkspace,
        BufferedReader reader,
        int dataColumn,
        int urlColumn,
        String ontologyName,
        String ontologyVersion)
        throws IOException {
      String line = null;
      int lineCount = 0;
      int fieldPos = 0;
      StringBuilder sb = new StringBuilder();
      writeMetaData(ontologyName, ontologyVersion, sb);
      Boolean singleColumnInfo = null;
      while ((line = reader.readLine()) != null) {
        boolean quotesAreBalanced = StringUtils.countOccurrencesOf(line, "\"") % 2 == 0;
        while (!quotesAreBalanced) {
          line = line.trim();
          line += reader.readLine();
          lineCount++;
          quotesAreBalanced = StringUtils.countOccurrencesOf(line, "\"") % 2 == 0;
        }
        if (singleColumnInfo == null) {
          boolean isSingleColumnOfData = isSingleColumnOntologyFile(line, dataColumn, urlColumn);
          singleColumnInfo = isSingleColumnOfData;
        }
        // skip any header lines that dont contain data
        if (!singleColumnInfo && lineCount == 0) {
          String[] testTokens = line.split(",");
          if (urlColumn > (testTokens.length)) {
            throwColumnIncorrectException(urlColumn, "urlcolumn");
          }
          if (testTokens[urlColumn - 1].indexOf("http") == -1) {
            lineCount++;
            continue;
          }
        }
        handleLine(line, dataColumn, urlColumn, sb, singleColumnInfo);
        lineCount++;
        if (lineCount >= MAX_TERMS_PER_FIELD) {
          ontologyDocumentInWorkspace.getFields().get(fieldPos).setData(sb.toString());
          sb = new StringBuilder();
          lineCount = 0;
          fieldPos++;
          // max limit is therefore 20 fields * 10000  = 200,000 ontology 'phrases' per document.
          // since 20 is the number of fields in the ontology form created by
          // CustomFormAppInitialiser
          if (fieldPos == ontologyDocumentInWorkspace.getFields().size()) {
            throw new ImportFailureException(
                "Your ontology file was too large and could not be fully stored in RSpace, please"
                    + " try splitting the file");
          }
          writeMetaData(ontologyName, ontologyVersion, sb);
        }
      }
      ontologyDocumentInWorkspace.getFields().get(fieldPos).setData(sb.toString());
    }

    private static void writeMetaData(
        String ontologyName, String ontologyVersion, StringBuilder sb) {
      sb.append(
          RSPACE_EXTONTOLOGY_NAME_ONTOLOGYFILE
              + ontologyName
              + RSPACE_EXTONTOLOGY_TAG_DELIMITER
              + RSPACE_EXTONTOLOGY_VERSION_ONTOLOGYFILES
              + ontologyVersion);
    }

    // Rob passed on that users want to have ontology files with just a single column of data.
    private boolean isSingleColumnOntologyFile(String data, int datacolumn, int urlcolumn) {
      return (!data.contains(",") && datacolumn == 1 && urlcolumn == 1);
    }

    private void handleLine(
        String s, int datacolumn, int urlcolumn, StringBuilder sb, boolean singleColumnOfData) {
      if (!s.contains(",") && !singleColumnOfData) {
        return;
      }
      s = s.trim();
      // csv ontology files are comma and quote delimited -
      // a comma inside a quote delimited block does not represent a new field
      String[] quoteDelimitedTokens = s.split(("\""));
      List<String> commaDelimitedTokens = new ArrayList<>();
      for (String qdt : quoteDelimitedTokens) {
        if (StringUtils.hasText(qdt)) {
          qdt = qdt.trim();
          int qdtPos = s.indexOf(qdt);
          // non quote delimited blocks start with ',' unless the initial block of text in the line.
          // (If the initial block IS quote delimited it will start at pos 1)
          if (qdt.charAt(0) == ',' || qdtPos == 0) {
            if (qdtPos != 0) {
              qdt =
                  qdt.substring(
                      1, qdt.length()); // initial comma is a hangover from the quote splitting
            }
            commaDelimitedTokens.addAll(Arrays.asList(qdt.split(",")));
          } else {
            commaDelimitedTokens.add(qdt);
          }
        } else {
          commaDelimitedTokens.add("");
        }
      }
      if (datacolumn > (commaDelimitedTokens.size())) {
        // note - downloaded csv from bioontologies were found to be unreliable - text had line
        // breaks mid sentence and irregular number of columns
        throwColumnIncorrectException(datacolumn, "datacolumn");
      } else if (urlcolumn > (commaDelimitedTokens.size())) {
        // note - downloaded csv from bioontologies were found to be unreliable - text had line
        // breaks mid sentence and irregular number of columns
        throwColumnIncorrectException(datacolumn, "urlcolumn");
      } else {
        if (singleColumnOfData) {
          sb.append(
              RSPACE_EXTONTOLOGY_TAG_DELIMITER
                  + commaDelimitedTokens.get(datacolumn - 1).replaceAll("\"", "")
                  + RSPACE_EXTONTOLOGY_URL_DELIMITER
                  + "NONE");
        } else {
          if (commaDelimitedTokens.get(urlcolumn - 1).toLowerCase().indexOf("http") == -1) {
            throw new ImportFailureException(
                "You have specified a url column which does not contain urls.");
          }
          sb.append(
              RSPACE_EXTONTOLOGY_TAG_DELIMITER
                  + commaDelimitedTokens.get(datacolumn - 1).replaceAll("\"", "")
                  + RSPACE_EXTONTOLOGY_URL_DELIMITER
                  + commaDelimitedTokens.get(urlcolumn - 1).replaceAll("\"", ""));
        }
      }
    }

    private static void throwColumnIncorrectException(int datacolumn, String columnType) {
      throw new ImportFailureException(
          String.format(
              "There are fewer columns in this csv file than the %s you specified at column %d",
              columnType, datacolumn + 1));
    }
  }

  @Autowired private RecordSigningManager signingManager;
  @Autowired private RecordManager recordMgr;
  @Autowired private UserManager userManager;
  @Autowired private FolderManager folderManager;
  @Autowired private FormManager formManager;
  private Long ontologyFormID;

  public void writeImportToOntologyDoc(
      InputStream inputStream,
      int dataColumn,
      int urlColumn,
      String ontologyName,
      String ontologyVersion)
      throws IOException {
    try {
      User user = userManager.getAuthenticatedUserInSession();
      String filename = ontologyName + "_version_" + ontologyVersion + ".ontology";
      BufferedReader reader =
          new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
      StructuredDocument ontologyDocumentInWorkspace = createOntologyDocInFolder(user, filename);
      new OntologyDocWriter()
          .writeToOntologyDoc(
              ontologyDocumentInWorkspace,
              reader,
              dataColumn,
              urlColumn,
              ontologyName,
              ontologyVersion);
      recordMgr.save(ontologyDocumentInWorkspace, user);
      String[] witnesses = new String[] {"NoWitnesses"};
      signingManager.signRecordNoPublishEvent(
          ontologyDocumentInWorkspace.getId(),
          user,
          witnesses,
          String.format("Signed as the ontology %s, version %s", ontologyName, ontologyVersion));
    } catch (Exception e) {
      if (e instanceof ImportFailureException) {
        throw e;
      } else {
        log.error("Ontology file import failed:" + e.getMessage());
        throw new ImportFailureException(
            "Your csv file is not in a format which RSpace can parse.");
      }
    }
  }

  private StructuredDocument createOntologyDocInFolder(User user, String fileName) {
    populateOntologyFormID();
    Folder folder = folderManager.getRootRecordForUser(user, user);
    StructuredDocument doc =
        recordMgr.createNewStructuredDocument(folder.getId(), ontologyFormID, user);
    doc.setName(fileName);
    return doc;
  }

  private void populateOntologyFormID() {
    if (ontologyFormID == null) {
      RSForm ontologyForm =
          formManager.findOldestFormByName(CustomFormAppInitialiser.ONTOLOGY_FORM_NAME);
      // There *should* always be a form, however if no ontology form found abort without errors -
      // we dont want this to prevent tag save etc
      if (ontologyForm != null) {
        ontologyFormID = ontologyForm.getId();
      }
    }
  }

  // every user has an own ontology file which stores all tags they create
  public void writeTagsToUsersOntologyTagDoc(User user, Set<String> unsortedUniqueTags) {
    populateOntologyFormID();
    // There *should* always be a form, however if no ontology form found abort without errors - we
    // dont want this to prevent tag save etc
    if (ontologyFormID != null) {
      Folder folder = folderManager.getRootRecordForUser(user, user);
      List<BaseRecord> userOntologyDocuments =
          recordMgr.getOntologyTagsFilesForUserCalled(user, USER_TAGS_ONTOLOGY_FILE);
      if (userOntologyDocuments.isEmpty()) {
        Folder ontologiesFolder = getOntologiesFolder(user, folder);
        StructuredDocument doc =
            recordMgr.createNewStructuredDocument(ontologiesFolder.getId(), ontologyFormID, user);
        doc.setName(USER_TAGS_ONTOLOGY_FILE);
        recordMgr.save(doc, user);
        userOntologyDocuments.add(doc);
      }
      List<String> tags = new ArrayList<>(unsortedUniqueTags);
      tags.sort(String::compareTo);
      for (BaseRecord rec : userOntologyDocuments) {
        StructuredDocument ontologyDocumentInWorkspace = (StructuredDocument) rec;
        ontologyDocumentInWorkspace.getFields().forEach(f -> f.setData(""));
        int fieldPos = 0;
        int tagCount = 0;
        StringBuilder builder = new StringBuilder();
        for (String tag : tags) {
          builder.append("<p>" + tag + "</p>");
          tagCount++;
          if (tagCount > 10000) {
            tagCount = 0;
            fieldPos++;
            // max limit is therefore 20 fields * 10000  = 200,000 ontology 'phrases' per document.
            if (fieldPos == ontologyDocumentInWorkspace.getFields().size()) {
              throw new ImportFailureException(
                  "Your ontology file was too large and could not be fully stored in RSpace, please"
                      + " try splitting the file");
            }
            ontologyDocumentInWorkspace.getFields().get(fieldPos).setData(builder.toString());
            builder = new StringBuilder();
          }
        }
        ontologyDocumentInWorkspace.getFields().get(fieldPos).setData(builder.toString());
        recordMgr.save(ontologyDocumentInWorkspace, user);
      }
    } else {
      log.error("Ontology form missing");
    }
  }

  private Folder getOntologiesFolder(User user, Folder folder) {
    Set<BaseRecord> contents = folder.getChildrens();
    Folder ontologiesFolder = null;
    for (BaseRecord item : contents) {
      if (item instanceof Folder) {
        if (item.getName().equals("Ontologies") && !item.isDeleted()) {
          ontologiesFolder = (Folder) item;
        }
      }
    }
    if (ontologiesFolder == null) {
      ontologiesFolder = folderManager.createNewFolder(folder.getId(), "Ontologies", user);
    }
    return ontologiesFolder;
  }

  // assumptions - 1) noone creates an ontology file using their own form which happens to be called
  // 'rspace tags from ontologies'
  // in the previous 30 minutes to doing an import of an archive
  public void updateImportedOntologiesWithCorrectForm(String uName) {
    User user = userManager.getUserByUsername(uName, true);
    populateOntologyFormID();
    List<StructuredDocument> ontologyDocumentsCreatedByImport =
        recordMgr.getontologyDocumentsCreatedInPastThirtyMinutesByCurrentUser(uName);
    RSForm ontologyForm =
        formManager.findOldestFormByName(CustomFormAppInitialiser.ONTOLOGY_FORM_NAME);
    for (StructuredDocument sd : ontologyDocumentsCreatedByImport) {
      sd.setForm(ontologyForm);
      sd.setIconId(ontologyForm.getIconId());
      recordMgr.save(sd, user);
    }
  }
}
