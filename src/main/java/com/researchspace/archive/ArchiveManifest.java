package com.researchspace.archive;

import com.researchspace.core.util.version.SemanticVersion;
import java.util.Collections;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.UUID;

/** Holds information as key:value pairs for the archive manifest file */
public class ArchiveManifest {
  /** The database version from which this was generated */
  public static final String DB_VERSIONKEY = "Database version";

  /**
   * Key for RSpace application from which this was generated This has a typo but fixing it breaks
   * backward compatibility.
   */
  public static final String RSPACE_APPLICATION_VERSION = "RSPace application version";

  /** Key for archive ID */
  public static final String ARCHIVE_ID = "archiveId";

  /** Identifies the source of the Archive, i.e., the application that generated RSpace */
  public static final String SOURCE = "archiveSource";

  /** Identifies the source of the Archive, i.e., the application that generated RSpace */
  public static final String RSPACE_SOURCE = "ResearchSpace";

  /** Field for user-entered description of the archive. */
  public static final String DESCRIPTION = "Description";

  /** The ArchiveScope of this archive. */
  public static final String SCOPE = "scope";

  private Map<String, String> keyToValue = new TreeMap<String, String>();

  public Map<String, String> getKeyToValue() {
    return Collections.unmodifiableMap(keyToValue);
  }

  /**
   * Adds an item to the manifest
   *
   * @param name
   * @param value
   */
  public void addItem(String name, String value) {
    keyToValue.put(name, value);
  }

  /**
   * GEts the manifest items
   *
   * @return
   */
  public Set<Entry<String, String>> getItems() {
    return keyToValue.entrySet();
  }

  @Override
  public String toString() {
    return "ArchiveManifest [keyToValue=" + keyToValue + "]";
  }

  /**
   * Writes manifest items to String, 1 per line, in format <code>
   * key:value
   * </code>
   *
   * @return
   */
  public String stringify() {
    StringBuffer sb = new StringBuffer();
    for (Entry<String, String> entry : getItems()) {
      sb.append(entry.getKey() + ":" + entry.getValue()).append("\n");
    }
    return sb.toString();
  }

  /**
   * Adds all map contents from the argument map to the manifest
   *
   * @param folderMap
   */
  public void addAll(Map<String, String> folderMap) {
    keyToValue.putAll(folderMap);
  }

  /**
   * Gets the database version that this archive was generated from, or returns {@link
   * SemanticVersion#UNKNOWN_VERSION} if the version could not be ascertained
   *
   * @return
   */
  public SemanticVersion getDatabaseVersion() {
    String version = keyToValue.get(DB_VERSIONKEY);
    if (version == null) {
      return SemanticVersion.UNKNOWN_VERSION;
    } else {
      try {
        return new SemanticVersion(version);
      } catch (IllegalArgumentException e) {
        return SemanticVersion.UNKNOWN_VERSION;
      }
    }
  }

  /**
   * Return the version of RSpace that generated the archive, or <code>null</code> if the version is
   * not specified, or if the version cannot be parsed.
   *
   * @return
   */
  public SemanticVersion getRSpaceAppVersion() {
    String version = keyToValue.get(RSPACE_APPLICATION_VERSION);
    if (version == null || !SemanticVersion.isValid(version)) {
      return null;
    }
    return new SemanticVersion(version);
  }

  /**
   * Return the scope of the archive.
   *
   * @return
   */
  public ExportScope getScope() {
    String version = keyToValue.get(SCOPE);
    return ExportScope.valueOf(version);
  }

  /**
   * Boolean test for whether this archive was generated by RSpace.
   *
   * @return
   */
  public boolean isRSpaceSource() {
    return keyToValue.get(SOURCE) != null && RSPACE_SOURCE.equals(keyToValue.get(SOURCE));
  }

  /**
   * Gets the value of the property with key {@link ArchiveManifest#SOURCE}
   *
   * @return
   */
  public String getSource() {
    return keyToValue.get(SOURCE);
  }

  /**
   * Gets the archive ID, if set. This should always be set if the archive was generated from
   * RSpace.
   *
   * @return the archive ID, or <code>null</code> if this was not set.
   */
  public String getArchiveId() {
    if (!isRSpaceSource()) {
      return null;
    } else {
      return keyToValue.get(ARCHIVE_ID);
    }
  }

  /**
   * Generates a unique id for this archive, if it doesn't already exist. If it does exist, the
   * original Id is returned.
   *
   * @return
   */
  public String generateArchiveIdInManifest() {

    if (getArchiveId() == null) {
      String archiveID = UUID.randomUUID().toString();
      addItem(ARCHIVE_ID, archiveID);
      return archiveID;
    } else {
      return getArchiveId();
    }
  }
}
