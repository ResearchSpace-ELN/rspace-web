package com.researchspace.dao.customliquibaseupdates;

import com.researchspace.Constants;
import com.researchspace.auth.ShiroRealm;
import com.researchspace.dao.UserDao;
import com.researchspace.model.User;
import com.researchspace.service.SessionControl;
import com.researchspace.service.impl.AbstractAppInitializor;
import java.util.concurrent.Callable;
import liquibase.database.Database;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.subject.SimplePrincipalCollection;
import org.apache.shiro.subject.Subject;
import org.hibernate.ScrollMode;
import org.hibernate.ScrollableResults;
import org.springframework.aop.framework.Advised;
import org.springframework.aop.support.AopUtils;

/**
 * Abstract class for updates requiring user permissions, where we want to simulate user actions and
 * the methods called check permissions. Subclasses should:
 *
 * <ul>
 *   <li>Implement <code>doUserSpecificAction</code>
 *   <li>Override <code>addBeans</code> but call super.addBeans() as first line in the method.
 * </ul>
 *
 * Also, you may need to add a temporary sysadmin user whose password we know so that we can login
 * as that user and perform authourised actions. See Changelog 1.36.xml for details of this, the
 * user is created before this task, and deleted afterwards.
 *
 * <p>The username and password can stay the same, just the id needs to be new. Suggest using
 * version number as prefix on id e.g. -1361. A negative ID will not be generated by MySQL or
 * Hibernate so this should be safe and not conflict with existing ids.
 */
public abstract class AbstractUpdateRequiringUserPermissions
    extends AbstractCustomLiquibaseUpdater {

  protected SecurityManager secManager;
  protected SessionControl realm;
  protected UserDao userDao;
  private String sysadminUname = Constants.RS_LIQUIBASE_ADMIN;
  private String sysadminPwd = AbstractAppInitializor.SYSADMIN_PWD;
  private static final int MAX_SESSION_LENGTH = 7_200_000; // 2 hours for the moment

  /**
   * For overriding in tests
   *
   * @param sysadminUname
   */
  public void setSysadminUname(String sysadminUname) {
    this.sysadminUname = sysadminUname;
  }

  /**
   * For overriding in tests
   *
   * @param sysadminUname
   */
  public void setSysadminPwd(String sysadminPwd) {
    this.sysadminPwd = sysadminPwd;
  }

  @Override
  protected void addBeans() {
    addSecurityBeans();
  }

  private void addSecurityBeans() {
    realm = context.getBean(SessionControl.class);
    ShiroRealm sr = null;
    if (AopUtils.isJdkDynamicProxy(realm)) {
      try {
        sr = (ShiroRealm) ((Advised) realm).getTargetSource().getTarget();
      } catch (Exception e) {
        logger.error("Error getting shiro realm target: ", e);
      }
    } else {
      sr = (ShiroRealm) realm; // expected to be cglib proxy then, which is simply a specialized
      // class
    }
    // we don't have a web manager when this is called, so need to temporarily used a default
    // manager
    secManager = new DefaultSecurityManager(sr);
    userDao = context.getBean(UserDao.class);
  }

  @Override
  protected void doExecute(Database database) {
    final ScrollableResults results =
        sessionFactory.getCurrentSession().createQuery("from User").scroll(ScrollMode.FORWARD_ONLY);
    // we don't have a session bound during startup, so need to tell the security realm not to refer
    // to a session
    realm.setIgnoreSession(true);
    // create a subject that we can login as sysadmin
    final Subject subject = new Subject.Builder(secManager).buildSubject();
    subject.getSession().setTimeout(MAX_SESSION_LENGTH); // 2h
    // direct login won't bind to thread, needs explicit handling
    subject.execute(
        new Callable<Boolean>() {
          public Boolean call() {
            try {
              subject.login(new UsernamePasswordToken(sysadminUname, sysadminPwd));
              int i = 0;
              while (results.next()) {
                User user = (User) results.get(0);
                logger.info("Looking at user {} / {} ", i++, user.getUsername());
                try {
                  SimplePrincipalCollection pc = new SimplePrincipalCollection();
                  pc.add(user.getUsername(), ShiroRealm.DEFAULT_USER_PASSWD_REALM);
                  subject.runAs(pc);
                  doUserSpecificAction(user);
                } finally {
                  subject.releaseRunAs();
                  sessionFactory.getCurrentSession().flush();
                  sessionFactory.getCurrentSession().evict(user);
                  sessionFactory.getCache().evictEntityRegions();
                }
              }
            } finally {
              // reset default
              realm.setIgnoreSession(false);
              subject.logout();
            }
            return true;
          }
        });
  }

  /**
   * Subclasses should implement this. Can assume that user is logged in and has permissions.
   *
   * @param user
   * @return <code>true</code> if action succeeded
   */
  protected abstract boolean doUserSpecificAction(User user);
}
